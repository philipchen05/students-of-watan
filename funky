#ifndef ACHIEVEMENT_H
#define ACHIEVEMENT_H

#include "observer.h"
#include "student.h"
#include "resource.h"

#include <map>
#include <memory>

class Student; // forward declaration

class Achievement: public Observer {
  protected:
    int id; // identifying number
    Student* owner; // student that has completed/achieved this achievement

    Achievement(int id, Student* owner = nullptr); // constructor

  public:
    virtual void notify(const Subject *sbj); // called by subject

    bool isOwned() const; // returns true if achievement has owner, otherwise false
    std::string getOwnerName() const; // returns owner's colour if achievement has owner, otherwise empty string
    int getId() const; // returns achievement's id (number)

    // returns cost of upgrading (or acquiring) an achievement
    virtual const std::map<Resource, int>& getUpgradeCost() const = 0;

    virtual ~Achievement() = 0; // abstract class
};

#endif
#ifndef BEGIN_H
#define BEGIN_H

#include "gamephase.h"
#include <memory>

// Begin class for managing beginning of game
class Begin: public GamePhase {
    public:
        Begin(Game* game); // Begin constructor
        ~Begin() = default; // Begin destructor
        void play() override; // Method for executing beginning of game events
};

#endif
#ifndef BOARD_H
#define BOARD_H

#include <vector>
#include <string>
#include <memory>
#include <map>
#include <set>
#include "tile.h"
#include "boardsetup.h"
#include "student.h"
#include "resource.h"

class Board {
private:
    // Tiles on the board
    std::vector<std::unique_ptr<Tile>> tiles;

    // Hard-coded criteria and goals
    std::vector<std::shared_ptr<Criterion>> criteria;
    std::vector<std::shared_ptr<Goal>> goals;

    // Map of criteria to their adjacent criteria and goals
    std::map<int, std::pair<std::set<int>, std::set<int>>> criterionMap;


    // Generate criteria and goals
    void generateCriteriaAndGoals();

    // Populate the criterion map with adjacency data
    void populateCriterionMap();

    // Output number in specified board format
    void outputNum(int num) const;

public:
    // Constructor
    Board(std::unique_ptr<BoardSetup> setup);

    // Check if it's valid to build at a specific location
    bool canBuildCriteria(int criterionId, const Student& student, bool begin) const;

    bool canBuildGoal(int goalId, const Student& student) const;

    bool isValid(int criterionId) const;

    // Get adjacent criteria for a given criterion ID
    bool emptyAdjacent(int criterionId) const;

    bool ownsGoal(int criterionId, const Student &student) const;
    Tile* getGeeseLocation(); 

    // Display the board
    void display() const;

    // Returns criteria vector
    const std::vector<std::shared_ptr<Criterion>>& getCriteria() const; 

    Criterion* getCriterion(int criterionId) const; // returns raw pointer to the criterion with the given id
    Goal* getGoal(int goalId) const;
    
    // Returns goals vector
    const std::vector<std::shared_ptr<Goal>>& getGoals() const;

    // Returns tiles vector
    const std::vector<std::unique_ptr<Tile>>& getTiles() const;

    // Returns a string of the board data
    std::string getData() const;
};

#endif#ifndef BOARDSETUP_H
#define BOARDSETUP_H

#include <vector>
#include <string>
#include <memory>
#include <iostream>
#include "tile.h"
#include <map>
#include <set>
#include <random>

class BoardSetup {
    protected:
        // a map of each tile's criteria (vertices)
        std::map<int, std::vector<int>> tilesCriteria = {{0, {0, 1, 3, 4, 8, 9}}, {1, {2, 3, 7, 8, 13, 14}}, {2, {4, 5, 9, 10, 15, 16}},
                                                      {3, {6, 7, 12, 13, 18, 19}}, {4, {8, 9, 14, 15, 20, 21}}, {5, {10, 11, 16, 17, 22, 23}},
                                                      {6, {13, 14, 19, 20, 25, 26}}, {7, {15, 16, 21, 22, 27, 28}}, {8, {18, 19, 24, 25, 30, 31}},
                                                      {9, {20, 21, 26, 27, 32, 33}}, {10, {22, 23, 28, 29, 34, 35}}, {11, {25, 26, 31, 32, 37, 38}},
                                                      {12, {27, 28, 33, 34, 39, 40}}, {13, {30, 31, 36, 37, 42, 42}}, {14, {32, 33, 38, 39, 44, 45}},
                                                      {15, {34, 35, 40, 41, 46, 47}}, {16, {37, 38, 43, 44, 48, 49}}, {17, {39, 40, 45, 46, 50, 51}},
                                                      {18, {44, 45, 49, 50, 52, 53}}
                                                      };
        // a map of each tile's goals (edges)
        std::map<int, std::vector<int>> tilesGoals = { {0, {0, 1, 2, 6, 7, 10}}, {1, {3, 5, 6, 13, 14, 18}}, {2, {4, 7, 8, 15, 16, 19}},
                                                    {3, {9, 12, 13, 20, 21, 26}}, {4, {10, 14, 15, 22, 23, 27}}, {5, {11, 16, 17, 24, 25, 28}},
                                                    {6, {18, 21, 22, 30, 31, 35}}, {7, {19, 23, 24, 32, 33, 36}}, {8, {26, 29, 30, 37, 38, 43}},
                                                    {9, {27, 31, 32, 39, 40, 44}}, {10, {28, 33, 34, 41, 42, 45}}, {11, {35, 38, 39, 47, 48, 52}},
                                                    {12, {36, 40, 41, 49, 50, 53}}, {13, {43, 46, 47, 54, 55, 60}}, {14, {44, 48, 49, 56, 57, 61}},
                                                    {15, {45, 50, 51, 58, 59, 62}}, {16, {52, 55, 56, 63, 64, 67}}, {17, {53, 57, 58, 65, 66, 68}},
                                                    {18, {61, 64, 65, 69, 70, 71}}
                                                    };

    public:

        virtual std::vector<std::unique_ptr<Tile>> generateTiles(
        const std::vector<std::shared_ptr<Criterion>>& criteria,
        const std::vector<std::shared_ptr<Goal>>& goals) = 0;
        virtual ~BoardSetup() = default;
};

class FileSetup : public BoardSetup {
    private:
        std::string boardDataString;
    public:
        FileSetup(const std::string& boardDataString);
        std::vector<std::unique_ptr<Tile>> generateTiles(
                const std::vector<std::shared_ptr<Criterion>>& criteria,
                const std::vector<std::shared_ptr<Goal>>& goals) override;
};

class RandomSetup : public BoardSetup {
    private: 
        std::mt19937 &gen; // Random number generator

    public:
        RandomSetup(std::mt19937 &gen);
        std::vector<std::unique_ptr<Tile>> generateTiles(
                const std::vector<std::shared_ptr<Criterion>>& criteria,
                const std::vector<std::shared_ptr<Goal>>& goals
        ) override;
    };

#endif
#ifndef CRITERION_H
#define CRITERION_H

#include "achievement.h"
#include "resource.h"

#include <string>
#include <ostream>

class Criterion: public Achievement {
  public:
    enum class CompletionLevel {INCOMPLETE = 0, ASSIGNMENT, MIDTERM, EXAM}; // completion levels

    // maps current level to the cost of upgrading to the next level,
    // where a cost is a map from each resource to the amount needed
    static const std::map<CompletionLevel, std::map<Resource, int>> upgradeCosts;

  private:
    CompletionLevel completion; // current level of completion
    std::map<CompletionLevel, std::map<Resource, int>> upgradeCost; // maps current level to the cost of upgrading to the next level,
    // where cost is a map from each resource to the amount of that resource needed

  public:
    Criterion(int id, Student* owner = nullptr, CompletionLevel completion = CompletionLevel::INCOMPLETE); // ctor

    void complete(Student* s); // sets criterion as completed by the given student
    void improve(); // upgrades criterion to the next completion level (e.g. assignment to midterm)

    void notify(const Subject *sbj) override; // adds resources earend from the notifying tile to the owner

    int getCompletion() const; // returns an integer [0, 3] representing the completion level 
    const std::map<Resource, int>& getUpgradeCost() const override; // returns the cost of upgrading to next level

    ~Criterion() override;
};

// prints criterion contents for debug [Criterion: (id: ID, isOwned: ISOWNED, owner: OWNER, comp: COMPLETIONLEVEL)]
std::ostream& operator<<(std::ostream &out, const Criterion &criterion);

#endif
#ifndef DICE_H
#define DICE_H

#include <random>

// Dice class
class Dice {
    private:
        std::mt19937 &gen; // Random number generator
    public:
        Dice(std::mt19937 &gen); // Dice constructor
        ~Dice() = default; // Dice destructor
        int roll(bool fair) const; // Dice roll method
};

#endif
#ifndef DICEROLL_H
#define DICEROLL_H

// DiceRoll abstract class for dice roll algorithm
class DiceRoll {
    public:
        virtual ~DiceRoll() = default; // virtual DiceRoll destructor
        virtual int roll() = 0; // Roll method
};

#endif
#ifndef END_H
#define END_H

#include "gamephase.h"

// End class for managing end of game
class End: public GamePhase {
    private:
        bool playAgain; // Whether or not players wish to play again
    public:
        End(Game* game); // End constructor
        ~End() = default; // End destructor
        void play() override; // Method for executing end of game events
        bool getPlayAgain() const; // Getter method for playAgain
};

#endif
#ifndef FAIRROLL_H
#define FAIRROLL_H

#include "diceroll.h"
#include <random>

// FairRoll class for fair dice roll algorithm
class FairRoll: public DiceRoll {
    private:
        std::mt19937 &gen; // Random number generator
    public:
        FairRoll(std::mt19937 &gen); // FairRoll constructor
        int roll() override; // Roll method
};

#endif
#ifndef GAME_H
#define GAME_H

#include "board.h"
#include "gamephase.h"
#include "resource.h"
#include "student.h"
#include <vector>
#include <memory>
#include <random>
#include <string>

// Game class; controls game flow
class Game {
    private:
        const std::vector<std::string> colours = {"Blue", "Red", "Orange", "Yellow"}; // Const vector storing player colours in specified game order
        const std::vector<Resource> resources = {Resource::CAFFEINE, Resource::LAB, Resource::LECTURE, Resource::STUDY, Resource::TUTORIAL}; // Const vector of resources in specified game order
        const size_t numPlayers = 4; // Number of players
        const size_t numResources = 5;
        static const int defaultSeed = 5489; // Default seed value

        std::unique_ptr<Board> board; // Unique pointer to Board object 
        std::vector<std::unique_ptr<Student>> players; // Vector containing pointers to players
        std::unique_ptr<GamePhase> gamePhase; // Unique pointer to GamePhase object
        int seed; // Seed for random number generation
        int turn; // Stores turn number; used for determining which player's turn it is
        bool loaded; // Whether or not game was loaded from previously saved game
        std::mt19937 gen; // Random number generator for game
        void initializePlayers(); // Initialize players at beginning of game
        bool hasWon() const; // Helper method for determining if a player has won
    public:
        Game(int seed, std::string loadFile, std::string boardFile); // Game constructor

        int getNumPlayers() const; // returns number of players
        Student* getPlayer(int index); // returns raw pointer to the index-th player
        Board* getBoard(); // returns raw pointer to board 

        void play(); // Method for playing game

        static const int getDefaultSeed() { return defaultSeed; }; // Returns default seed value
};

#endif
#ifndef GAMEPHASE_H
#define GAMEPHASE_H

#include <memory>

class Game;

// GamePhase abstract class
class GamePhase {
    protected:
        Game* game; // Pointer to Game object
    public:
        GamePhase(Game* game); // GamePhase constructor
        virtual ~GamePhase() = default; // GamePhase destructor
        virtual void play() = 0; // Method for executing game phase events
        virtual bool getPlayAgain() const; // Return whether or not players wish to play again
};

#endif
#ifndef GOAL_H
#define GOAL_H

#include "achievement.h"
#include "resource.h"
#include "student.h"

#include <string>
#include <ostream>

class Student; // forward declaration
class Criterion; // forward declaration
class Achievement; // forward declaration

class Goal: public Achievement {
  public:
    // cost of achieving this goal
    static const std::map<Resource, int> upgradeCost;
  private:
    bool achieved; // whether or not this goal was achieved 
    
  public:
    Goal(int id, Student* owner = nullptr, bool achieved = false); // ctor
    void achieve(Student* s); // sets goal as achieved by the given student
    const std::map<Resource, int>& getUpgradeCost() const override; // returns the cost of upgrading to the next level (i.e. achieving the goal)
    ~Goal();
};

// prints goal contents for debug [Goal: (id: ID, isOwned: ISOWNED, owner: OWNER, ach: ACHIEVED)]
std::ostream& operator<<(std::ostream &out, const Goal &goal);

#endif
#ifndef LOADEDROLL_H
#define LOADEDROLL_H

#include "diceroll.h"

// LoadedRoll class for loaded dice roll algorithm
class LoadedRoll: public DiceRoll {
    public:
        int roll() override; // Roll method
};

#endif
#ifndef OBSERVER_H
#define OBSERVER_H

#include "subject.h"

class Observer {
  public:
    virtual void notify(const Subject *sbj) = 0;
    virtual ~Observer() = default;
};

#endif
#ifndef RESOURCE_H
#define RESOURCE_H

#include <iostream>
#include <string>

enum class Resource {
    CAFFEINE = 0,
    LAB,
    LECTURE,
    STUDY,
    TUTORIAL,
    NETFLIX,
};

// Converts string to Resource
Resource resourceFromString(std::string s);

// Converts int to Resource
Resource resourceFromInt(int value);

// Converts Resource to string
std::string resourceToString(Resource type);

// Converts Resource to int
int resourceToInt(Resource type);

// Overloaded operator<< method for outputting Resource types
std::ostream &operator<<(std::ostream &out, const Resource &r);

#endif
#ifndef STUDENT_H
#define STUDENT_H

#include "achievement.h"
#include "resource.h"

#include <string>
#include <memory>
#include <map>


// forward declaration
class Goal; 
class Criterion;
class Achievement;

class Student {
  private:
    static const std::map<Resource, int> defaultResources;

    std::string colour; // student's colour (name)
    int number; // student's place in order of turns [1, 4]
    std::map<Resource, int> resources; // number of each resource that student has: resource |-> amount

    std::vector<std::shared_ptr<Criterion>> criteria; // list of all criteria that student has completed
    std::vector<std::shared_ptr<Goal>> goals; // list of all goals that student has achieved

  public:
    Student(std::string colour, int number, int numVP = 0, const std::map<Resource, int> &resources = defaultResources, 
            std::vector<std::shared_ptr<Criterion>> criteria = {}, std::vector<std::shared_ptr<Goal>> goals = {});

    void addCriterion(Criterion *c); // adds criterion to student's list of completed criteria
    void improve(Criterion *c); // attempts to improve the given criterion
    void addGoal(Goal *g); // adds goal to the list of student's list of achieved goals

    void addResources(Resource type, int amount); // adds specified amount of the specified resource
    void removeResources(Resource type, int amount); // removes specified amount of the specified resource

    const std::string& getColour() const; // returns student colour (name)
    int getVP() const; // returns number of victory points
    const std::map<Resource, int>& getResources() const; // returns student's current resources
    int getResource(Resource type) const; // returns the number of resources of the given type
    int getTotalResources() const; // returns total number of resources
    std::string getData() const; // returns string with all student data to be saved to file
    
    void printStatus() const; // prints status (victory points and available resources)
    void printCriteria() const; // prints completed criteria

    ~Student();
};

#endif
#ifndef SUBJECT_H
#define SUBJECT_H
#include <vector>

class Observer; // forward declaration

class Subject {
  private:
    std::vector<Observer*> observers;

  protected:
    void attach( Observer* o );
    void detach( Observer* o );
    
  public:
    void notifyObservers();
    virtual ~Subject() = default;
};

#endif
#ifndef TILE_H
#define TILE_H

#include "subject.h"

#include <string>
#include <vector>
#include <memory>
#include <ostream>

#include "criterion.h"
#include "goal.h"
#include "resource.h"


class Tile: public Subject {
  private:
    Resource type;
    int value, location;
    bool geese;

    std::vector<std::shared_ptr<Criterion>> criteria;
    std::vector<std::shared_ptr<Goal>> goals;

  public:
    Tile(Resource type, int value, int location, const std::vector<std::shared_ptr<Criterion>> &criteria, const std::vector<std::shared_ptr<Goal>> &goals);

    bool hasGeese() const; // returns true if there are geese on the tile, otherwise false
    Resource getType() const; // returns type of resource
    int getValue() const; // returns value of tile
    int getLocation() const; // return location of tile
    std::vector<std::shared_ptr<Criterion>>& getCriteria(); // return criteria associated with tile
    std::vector<std::shared_ptr<Goal>>& getGoals(); // return goals associated with tile

    void setGeese(bool geese); // sets whether or not geese are on tile
 
    ~Tile();
};

// prints tile contents for debug [Tile: (type: TYPE, loc: LOCATION, val: VALUE)]
std::ostream& operator<<(std::ostream &out, const Tile &tile);

#endif
#ifndef TURNBEGIN_H
#define TURNBEGIN_H

#include "turn.h"
#include "dice.h"
#include "resource.h"
#include <map>
#include <random>

// TurnBegin class for managing beginning of player turn
class TurnBegin: public Turn {
    private:
        Dice dice; // Dice object
        std::mt19937 &gen; // Random number generator
        void moveGeese(); // Move geese to new location
        void updateResources(int roll); // Update player resources based on dice roll
        bool printUpdates(std::vector<std::map<Resource, int>> &prevResources, bool gain, std::vector<int>* amountsLost) const; // Output resource updates; returns true if at least one resource updated
        bool printGains(std::vector<std::map<Resource, int>> &prevResources) const; // Output resource gains; returns true if at least one resource was gained
        bool printLosses(std::vector<std::map<Resource, int>> &prevResources, std::vector<int>* amountsLost) const; // Output resource losses; returns true if at least one resource was lost
        Resource loseResource(Student& s); // Loses one random resource and returns it; proportional probabilities of losing each resource
    public:
        TurnBegin(Game* game, Student* player, std::mt19937 &gen); // TurnBegin constructor
        virtual ~TurnBegin() = default; // TurnBegin destructor
        void play() override; // Method for playing beginning of turn events
};

#endif
#ifndef TURNEND_H
#define TURNEND_H

#include "turn.h"

// TurnEnd class for managing end of player turn
class TurnEnd: public Turn {
    private:
        void board(); // Display board
        void status(); // Print status of each student in order of student index
        void criteria(); // Print current student's criteria
        void achieve(int id); // Achieve goal
        void complete(int id); // Complete criterion
        void improve(int id); // Improve criterion
        bool canAfford(Achievement* a); // Determine if player can afford desired goal/achievement
        void purchase(Achievement* a); // Deducts cost of given achievement from player resources
        void trade(std::string colour, std::string give, std::string take); // Trade resources with another player
        void save(std::string file); // Saves current game state to specified file
        void help(); // Print help guide
    public:
        TurnEnd(Game* game, Student* player); // TurnEnd constructor
        virtual ~TurnEnd() = default; // TurnEnd destructor
        void play() override; // Method for playing end of turn events
};

#endif
#ifndef TURN_H
#define TURN_H

#include "gamephase.h"
#include "student.h"

// Turn abstract class
class Turn: public GamePhase {
    protected:
        Student* player; // Pointer to player whose turn it is
    public:
        Turn(Game* game, Student* player); // Turn constructor
        virtual ~Turn() = default; // Turn destructor
};

#endif
